package simugen.core.rng;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

import simugen.core.interfaces.DataGenerator;
import simugen.core.interfaces.EngineTick;

/**
 * Generates a random {@link Number} based on an empirical set of data.<br>
 * <br>
 * Example:<br>
 * The {@link EmpiricalGenerator} gets instantiated with the list<br>
 * <br>
 * {1,3,3,4,8,10} <br>
 * <br>
 * Then the numbers 1, 4, 8, and 10 have an equal chance of being generated
 * (1/6th of the time) and the number 3 has double the chance (1/3rd) of being
 * generated. No other numbers will be able to be generated by this instance of
 * {@link EmpiricalGenerator}.
 * 
 * @author Lorelei
 *
 */
public class EmpiricalGenerator implements DataGenerator<Number>, Serializable {
	private static final long serialVersionUID = 1L;

	private ArrayList<Double> values = new ArrayList<>();

	private ArrayList<Double> probabilities = new ArrayList<>();

	private Map<Double, Double> mapValueToProbabilities = new HashMap<>();

	private Map<Double, Double> cdf = new HashMap<>();

	private boolean ready = false;

	/**
	 * @param d A value to be added to the empirical distribution.
	 */
	public void addValue(double d) {
		values.add(d);

		ready = false;
	}

	/**
	 * Compute the probabilities based on the empirical distribution.<br>
	 * <br>
	 * For example, {1,3,3,4,8,10}; 3 would have a probability of 0.333... and 1
	 * would have a probability of 0.166...
	 */
	public void computeProbabilities() {
		double n = values.size();

		double prob;

		@SuppressWarnings("unchecked")
		ArrayList<Double> buffer = (ArrayList<Double>) values.getClass().cast(values.clone());

		buffer.sort(new Comparator<Double>() {
			@Override
			public int compare(Double o1, Double o2) {
				int count1 = getNumberOf(o1);
				int count2 = getNumberOf(o2);

				return Integer.compare(count1, count2);
			}
		});

		values = buffer;

		for (double d : values) {
			if (mapValueToProbabilities.containsKey(d)) {
				continue;
			}

			double m = getNumberOf(d);

			prob = m / n;

			mapValueToProbabilities.put(d, prob);
		}

		createCDF();

		ready = true;
	}

	/**
	 * Generate the Cumulative Distribution Function.<br>
	 * <br>
	 * In probabilities, the cumulative distribution function is a function that has
	 * a range from {0,1} in which a random number from {0,1} will generate a
	 * variate, X from the input values.<br>
	 * <br>
	 * The CDF for an empirical distribution is a step function. Wikipedia has a
	 * better explanation of CDFs than a little snippet in JavaDoc could ever
	 * convey, and if you truly want to understand, I recommend you visiting the
	 * link below:
	 * 
	 * @see <a href=
	 *      "https://en.wikipedia.org/wiki/Cumulative_distribution_function">Wikipedia
	 *      - Cumulative Distribution Function</a>
	 */
	private void createCDF() {
		double last = 0;

		for (Double value : mapValueToProbabilities.keySet().toArray(new Double[0])) {
			last += mapValueToProbabilities.get(value);

			mapValueToProbabilities.put(value, last);

			cdf.put(last, value);
		}

		probabilities.clear();

		probabilities.addAll(mapValueToProbabilities.values());
	}

	/**
	 * @param d The {@link Double} that is to be checked for in the list.
	 * @return The number of times this value exists in the list.
	 */
	private int getNumberOf(double d) {
		int count = 0;
		for (double val : values) {
			if (Double.valueOf(val).equals(d)) {
				count++;
			}
		}
		return count;
	}

	/**
	 * Get the next random variate from this distribution.
	 */
	@Override
	public Number getNext(EngineTick tick) {
		assert ready;

		double d = tick.getNextRand();

		// If the probability of a number is 0.25,
		// and the passed probability, d, is <=0.25, it's valid.
		// Because of how CDFs work, successive numbers have the previous probability
		// added to them. For example, if {1,2,3,4} was the distribution, the CDF would
		// be: x = {1,2,3,4} y = {0.25, 0.5, 0.75, 1}
		// The steps between each y-value is 0.25, and as such with a random number
		// {0,1} there's 25% chance of generating a variate from any of the four
		// x-values. This is highly simplified.
		for (Double prob : probabilities) {
			if (d <= prob) {
				return cdf.get(prob);
			}
		}

		throw new IllegalStateException("Could not find a valid number!");
	}
}
